<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Movie Sharing Mini App</title>
    <!-- Official Telegram WebApp script -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --tg-theme-bg-color: #ffffff;
            --tg-theme-text-color: #222222;
            --tg-theme-hint-color: #999999;
            --tg-theme-link-color: #2481cc;
            --tg-theme-button-color: #2481cc;
            --tg-theme-button-text-color: #ffffff;
            --tg-theme-secondary-bg-color: #f5f5f5;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #222222);
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 16px;
        }
        
        h1 {
            font-size: 22px;
            margin: 16px 0;
            color: var(--tg-theme-text-color, #222222);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .movie-count {
            font-size: 14px;
            color: var(--tg-theme-hint-color, #999999);
            font-weight: normal;
        }
        
        .movie-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .movie-card-container {
            position: relative;
            overflow: hidden;
            border-radius: 12px;
        }
        
        .movie-card {
            background-color: var(--tg-theme-secondary-bg-color, #f5f5f5);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 1;
            transition: transform 0.3s ease-out;
            display: flex;
            gap: 16px;
        }
        
        .movie-poster-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 80px;
            flex-shrink: 0;
        }
        
        .movie-poster {
            width: 80px;
            height: 120px;
            flex-shrink: 0;
            border-radius: 6px;
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .movie-poster img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .movie-content {
            flex: 1;
            min-width: 0; /* Important for text overflow handling */
            position: relative; /* Add this for absolute positioning of the link button */
        }
        
        .imdb-link {
            position: absolute;
            bottom: 0;
            right: 0;
            background-color: #f5c518; /* IMDb yellow */
            color: #000000;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 13px;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: opacity 0.2s;
        }
        
        .imdb-link:hover {
            opacity: 0.9;
        }
        
        .movie-description {
            font-size: 14px;
            line-height: 1.5;
            color: var(--tg-theme-text-color, #222222);
            margin: 8px 0 32px 0; /* Add bottom margin to prevent overlap with the button */
        }
        
        .swipe-hint-left, .swipe-hint-right {
            position: absolute;
            top: 0;
            height: 100%;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            z-index: 0;
            opacity: 0;
        }
        
        .swipe-hint-left {
            left: 0;
            background-color: #4caf50; /* Green when swiping right */
            justify-content: flex-start;
            padding-left: 20px;
        }
        
        .swipe-hint-right {
            right: 0;
            background-color: #f44336; /* Red when swiping left */
            justify-content: flex-end;
            padding-right: 20px;
        }
        
        .movie-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }
        
        .movie-title-container {
            flex: 1;
            min-width: 0; /* Ensures text truncation works */
        }
        
        .movie-title {
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            display: inline;
        }
        
        .movie-year {
            font-size: 16px;
            color: var(--tg-theme-hint-color, #999999);
            font-weight: normal;
            margin-left: 4px;
        }
        
        .imdb-rating {
            display: flex;
            align-items: center;
            background-color: #f5c518; /* IMDb yellow */
            color: #000000;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
            margin-left: 8px;
            white-space: nowrap;
        }
        
        .star-icon {
            margin-right: 3px;
            font-size: 14px;
        }
        
        .movie-genre {
            display: inline-block;
            font-size: 13px;
            color: var(--tg-theme-hint-color, #999999);
            margin-bottom: 8px;
        }
        
        .card-footer {
            width: 80px;  /* Match poster width */
            height: 24px; /* Make it taller */
        }
        
        .btn {
            background-color: var(--tg-theme-button-color, #2481cc);
            color: var(--tg-theme-button-text-color, #ffffff);
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
            display: inline-flex;
            align-items: center;
        }
        
        .btn:hover {
            opacity: 0.9;
        }
        
        .btn-sm {
            padding: 4px 12px;
            font-size: 13px;
        }
        
        .action-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 12px;
        }
        

        /* Rating display */
        .rating-bar {
            display: flex;
            width: 100%;
            height: 100%;
            border-radius: 4px;
            overflow: hidden;
        }

        .likes-bar {
            background-color: #90ee90; /* Light green */
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #006400; /* Dark green text */
            font-size: 12px;
            font-weight: bold;
            padding: 0 4px;
            min-width: 24px; /* Ensure minimum width for small numbers */
        }

        .dislikes-bar {
            background-color: #ffcccb; /* Light red */
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #8b0000; /* Dark red text */
            font-size: 12px;
            font-weight: bold;
            padding: 0 4px;
            min-width: 24px; /* Ensure minimum width for small numbers */
        }

        .rating-display {
            display: flex;
            height: 100%;
            margin-top: 0;
        }
        
        .likes, .dislikes {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
            flex: 1;
            justify-content: center;
        }
        
        .likes {
            color: #4caf50; /* Green */
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            padding-right: 8px;
        }
        
        .dislikes {
            color: #f44336; /* Red */
            padding-left: 8px;
        }
        
        .heart-icon {
            font-size: 16px;
        }
        
        /* Error container styles */
        #errorContainer {
            background-color: rgba(244, 67, 54, 0.1);
            border: 1px solid #f44336;
            border-radius: 8px;
            color: #f44336;
            font-size: 14px;
            margin-top: 20px;
            padding: 12px;
            text-align: left;
            word-break: break-word;
            display: none;
        }
        
        .error-title {
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .not-telegram {
            background-color: rgba(255, 193, 7, 0.1);
            color: #ff9800;
            padding: 12px;
            border-radius: 8px;
            margin: 16px 0;
            text-align: center;
            display: none;
            font-size: 14px;
        }
        
        .swipe-instruction {
            text-align: center;
            color: var(--tg-theme-hint-color, #999999);
            font-size: 14px;
            margin: 8px 0 16px;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.02);
            border-radius: 8px;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 0;
            color: var(--tg-theme-hint-color, #999999);
            display: none;
        }
        
        .reset-btn {
            display: block;
            margin: 20px auto 0;
        }
        
        /* Add movie form styles */
        .add-movie-section {
            margin-top: 30px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            padding-top: 20px;
        }
        
        .add-movie-title {
            font-size: 18px;
            margin: 0 0 16px 0;
            color: var(--tg-theme-text-color, #222222);
        }
        
        .add-movie-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .input-button-group {
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }
        
        .input-button-group .form-group {
            flex: 1;
            margin-bottom: 0;
        }
        
        .input-button-group .add-movie-btn {
            white-space: nowrap;
            margin-top: 0;
            height: 42px;
            align-self: flex-start;
        }
        
        .form-input {
            height: 42px;
            box-sizing: border-box;
        }
        
        .form-help {
            margin-top: 4px;
        }
        
        .form-group {
            width: 100%;
        }
        
        .form-input, .form-textarea {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            font-size: 14px;
            background-color: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #222222);
            font-family: inherit;
            box-sizing: border-box;
        }
        
        .form-help {
            font-size: 12px;
            color: var(--tg-theme-hint-color, #999999);
            margin-top: 4px;
        }
        
        .form-textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        .form-input:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--tg-theme-button-color, #2481cc);
        }
        
        .add-movie-btn {
            align-self: flex-end;
            margin-top: 8px;
        }
        
        /* Genre filter styles */
        .genre-filter {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
            padding: 4px 0;
            overflow-x: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        .genre-filter::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        
        .genre-tag {
            background-color: var(--tg-theme-secondary-bg-color, #f5f5f5);
            color: var(--tg-theme-hint-color, #999999);
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 14px;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        
        .genre-tag.active {
            background-color: var(--tg-theme-button-color, #2481cc);
            color: var(--tg-theme-button-text-color, #ffffff);
        }
        
        .genre-tag:hover:not(.active) {
            border-color: var(--tg-theme-button-color, #2481cc);
            color: var(--tg-theme-text-color, #222222);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            Friends recommendations
            <span id="movieCount" class="movie-count">(5)</span>
        </h1>
        
        <div id="notTelegram" class="not-telegram">
            This app works best within the Telegram application.
        </div>
        
        <div id="genreFilter" class="genre-filter">
            <div class="genre-tag active" data-genre="all">All</div>
            <div class="genre-tag" data-genre="action">Action</div>
            <div class="genre-tag" data-genre="drama">Drama</div>
            <div class="genre-tag" data-genre="sci-fi">Sci-Fi</div>
            <div class="genre-tag" data-genre="crime">Crime</div>
            <div class="genre-tag" data-genre="thriller">Thriller</div>
        </div>
        
        <div class="swipe-instruction">
            Swipe right to LIKE, swipe left to DISLIKE
        </div>
        
        <div id="emptyState" class="empty-state">
            <p>No more movies in your list</p>
            <button id="resetBtn" class="btn reset-btn">Reset List</button>
        </div>
        
        <div class="movie-list" id="movieList">
            <!-- Movie cards will be inserted here -->
        </div>
        
        <div class="add-movie-section">
            <h3 class="add-movie-title">Add New Movie</h3>
            <div class="add-movie-form">
                <div class="input-button-group">
                    <div class="form-group">
                        <input type="url" id="imdbUrl" class="form-input" placeholder="IMDb URL (e.g. https://www.imdb.com/title/tt0062455)" required>
                        <div class="form-help">Paste the full IMDb movie URL</div>
                    </div>
                    <button id="addMovieBtn" class="btn add-movie-btn">Add Movie</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Error container -->
    <div id="errorContainer">
        <div class="error-title">Error:</div>
        <div id="errorMessage"></div>
    </div>

    <script>
        // Sample movie urls
        const sampleMovieUrls = [
            "https://www.imdb.com/title/tt13406094",
            "https://www.imdb.com/title/tt1375666",
            "https://www.imdb.com/title/tt0133093",
            "https://www.imdb.com/title/tt10638522",
            "https://www.imdb.com/title/tt3920596/"
        ];
        // Sample movie data
        let movies = [];
        
        // Store original movies for reset functionality
        const originalMovies = [...movies];
        
        // Global error handler function
        function showError(error, details = '') {
            console.error('Error:', error);
            const errorContainer = document.getElementById('errorContainer');
            const errorMessage = document.getElementById('errorMessage');
            
            let errorText = error;
            if (error instanceof Error) {
                errorText = error.message;
                if (error.stack) {
                    details += '\n\nStack: ' + error.stack;
                }
            }
            
            errorMessage.textContent = errorText + (details ? '\n\nDetails: ' + details : '');
            errorContainer.style.display = 'block';
        }
        
        // Catch all global errors
        window.onerror = function(message, source, lineno, colno, error) {
            showError(error || message, `Location: ${source}:${lineno}:${colno}`);
            return true; // Prevents the default error handling
        };
        
        // Catch unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
            showError('Unhandled Promise Rejection', event.reason);
        });
        
        // Update movie count display
        function updateMovieCount() {
            const movieCountElement = document.getElementById('movieCount');
            movieCountElement.textContent = `(${movies.length})`;
            
            // Show/hide empty state
            const emptyStateElement = document.getElementById('emptyState');
            if (movies.length === 0) {
                emptyStateElement.style.display = 'block';
            } else {
                emptyStateElement.style.display = 'none';
            }
        }
        
        // Create movie card element with swipe functionality
        function createMovieCard(movie) {
            const movieCardContainer = document.createElement('div');
            movieCardContainer.className = 'movie-card-container';
            movieCardContainer.dataset.movieId = movie.imdbID;
            
            // Add swipe hints
            const swipeLeftHint = document.createElement('div');
            swipeLeftHint.className = 'swipe-hint-left';
            swipeLeftHint.textContent = 'LIKE';
            swipeLeftHint.style.opacity = 0;
            
            const swipeRightHint = document.createElement('div');
            swipeRightHint.className = 'swipe-hint-right';
            swipeRightHint.textContent = 'DISLIKE';
            swipeRightHint.style.opacity = 0;

            // Calculate percentages for likes/dislikes bar
            const totalVotes = movie.likesCount + movie.dislikesCount;
            const likesPercentage = totalVotes === 0 ? 50 : Math.round((movie.likesCount / totalVotes) * 100);
            const dislikesPercentage = 100 - likesPercentage;
            
            // Create movie card
            const movieCard = document.createElement('div');
            movieCard.className = 'movie-card';
            movieCard.innerHTML = `
                <div class="movie-poster-container">
                    <div class="movie-poster">
                        <img src="${movie.poster}" alt="${movie.title} poster" onerror="this.src='data:image/svg+xml;utf8,<svg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'80\\' height=\\'120\\' viewBox=\\'0 0 80 120\\'><rect width=\\'80\\' height=\\'120\\' fill=\\'%23eee\\'/><text x=\\'50%\\' y=\\'50%\\' font-family=\\'Arial\\' font-size=\\'12\\' text-anchor=\\'middle\\' fill=\\'%23999\\'>No image</text></svg>'">
                    </div>
                    <div class="card-footer">
                        <div class="rating-display">
                            <div class="rating-bar">
                                <div class="likes-bar" style="width: ${likesPercentage}%">
                                    ${movie.likesCount}
                                </div>
                                <div class="dislikes-bar" style="width: ${dislikesPercentage}%">
                                    ${movie.dislikesCount}
                                </div>
                            </div>
                        </div>                        
                    </div>
                </div>
                <div class="movie-content">
                    <div class="movie-header">
                        <div class="movie-title-container">
                            <h3 class="movie-title">${movie.title}</h3>
                            <span class="movie-year">(${movie.year})</span>
                        </div>
                        <div class="imdb-rating">
                            <span class="star-icon">★</span>
                            <span>${movie.imdbRating}</span>
                        </div>
                    </div>
                    <div class="movie-genre">${movie.genre}</div>
                    <p class="movie-description">${movie.description}</p>
                    <a href="https://www.imdb.com/title/${movie.imdbID}" target="_blank" class="imdb-link">
                        <span>IMDb</span>
                        <span>↗</span>
                    </a>
                </div>
            `;
            
            // Add swipe functionality
            let startX = 0;
            let currentX = 0;
            let isDragging = false;
            
            // Touch events for mobile
            let startY = 0;
            let isScrolling = false;
            let touchStartTime = 0;
            
            movieCard.addEventListener('touchstart', function(e) {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                touchStartTime = Date.now();
                isDragging = false;
                isScrolling = false;
                
                // Don't prevent default here to allow scrolling
            }, { passive: true });
            
            movieCard.addEventListener('touchmove', function(e) {
                const currentY = e.touches[0].clientY;
                currentX = e.touches[0].clientX;
                const diffX = currentX - startX;
                const diffY = currentY - startY;
                
                // Determine if this is a scroll or a swipe
                if (!isDragging && !isScrolling) {
                    // If vertical movement is greater than horizontal, it's a scroll
                    if (Math.abs(diffY) > Math.abs(diffX)) {
                        isScrolling = true;
                        return; // Allow normal scrolling
                    }
                    
                    // If horizontal movement is significant, it's a swipe
                    if (Math.abs(diffX) > 10) {
                        isDragging = true;
                    }
                }
                
                // If we determined this is a scroll, let the browser handle it
                if (isScrolling) return;
                
                // If we determined this is a swipe, handle it
                if (isDragging) {
                    // Prevent default only if we're swiping horizontally
                    e.preventDefault();
                    
                    // Limit the drag distance
                    if (Math.abs(diffX) < 150) {
                        movieCard.style.transform = `translateX(${diffX}px)`;
                    } else {
                        // If swiped far enough, prepare for removal
                        const direction = diffX > 0 ? 1 : -1;
                        movieCard.style.transform = `translateX(${direction * 150}px)`;
                    }
                    
                    // Show appropriate hint based on swipe direction
                    if (diffX < -30) {
                        // Swiping left - show red right indicator
                        swipeRightHint.style.opacity = Math.min(1, Math.abs(diffX) / 100);
                        swipeLeftHint.style.opacity = 0;
                    } else if (diffX > 30) {
                        // Swiping right - show green left indicator
                        swipeLeftHint.style.opacity = Math.min(1, Math.abs(diffX) / 100);
                        swipeRightHint.style.opacity = 0;
                    }
                }
            }, { passive: false });
            
            movieCard.addEventListener('touchend', function() {
                // Only process if we were dragging (not scrolling)
                if (!isDragging) return;
                
                const touchDuration = Date.now() - touchStartTime;
                const diffX = currentX - startX;
                
                // If swiped far enough or with enough velocity, remove the card
                const velocity = Math.abs(diffX) / touchDuration;
                if (Math.abs(diffX) > 100 || (Math.abs(diffX) > 40 && velocity > 0.5)) {
                    removeMovie(movie.imdbID);
                } else {
                    // Otherwise, snap back
                    movieCard.style.transform = 'translateX(0)';
                    swipeLeftHint.style.opacity = 0;
                    swipeRightHint.style.opacity = 0;
                }
                
                isDragging = false;
            });
            
            // Mouse events for desktop
            movieCard.addEventListener('mousedown', function(e) {
                // Only start dragging if it's a mouse event (not a tap)
                if (e.pointerType !== 'touch') {
                    startX = e.clientX;
                    currentX = e.clientX; // Initialize currentX
                    touchStartTime = Date.now();
                    isDragging = true;
                    e.preventDefault();
                }
            });
            
            movieCard.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                currentX = e.clientX;
                const diffX = currentX - startX;
                
                // Only start showing visual feedback if the drag is intentional
                if (Math.abs(diffX) > 10) {
                    // Limit the drag distance
                    if (Math.abs(diffX) < 150) {
                        movieCard.style.transform = `translateX(${diffX}px)`;
                    } else {
                        // If dragged far enough, prepare for removal
                        const direction = diffX > 0 ? 1 : -1;
                        movieCard.style.transform = `translateX(${direction * 150}px)`;
                    }
                    
                    // Show appropriate hint based on swipe direction
                    if (diffX < -30) {
                        // Swiping left - show red right indicator
                        swipeRightHint.style.opacity = Math.min(1, Math.abs(diffX) / 100);
                        swipeLeftHint.style.opacity = 0;
                    } else if (diffX > 30) {
                        // Swiping right - show green left indicator
                        swipeLeftHint.style.opacity = Math.min(1, Math.abs(diffX) / 100);
                        swipeRightHint.style.opacity = 0;
                    }
                }
            });
            
            movieCard.addEventListener('mouseup', function(e) {
                if (!isDragging) return;
                
                const touchDuration = Date.now() - touchStartTime;
                const diffX = currentX - startX;
                
                // Only remove if there was significant movement
                if (Math.abs(diffX) > 100 || (Math.abs(diffX) > 40 && touchDuration < 300)) {
                    removeMovie(movie.imdbID);
                } else {
                    // Otherwise, snap back
                    movieCard.style.transform = 'translateX(0)';
                    swipeLeftHint.style.opacity = 0;
                    swipeRightHint.style.opacity = 0;
                }
                
                isDragging = false;
            });
            
            movieCard.addEventListener('mouseleave', function() {
                if (isDragging) {
                    movieCard.style.transform = 'translateX(0)';
                    swipeLeftHint.style.opacity = 0;
                    swipeRightHint.style.opacity = 0;
                    isDragging = false;
                }
            });
            
            // Assemble the card container
            movieCardContainer.appendChild(swipeLeftHint);
            movieCardContainer.appendChild(movieCard);
            movieCardContainer.appendChild(swipeRightHint);
            
            return movieCardContainer;
        }
        
        // Remove movie from list
        function removeMovie(movieId) {
            // Find the card element
            const movieCardContainer = document.querySelector(`.movie-card-container[data-movie-id="${movieId}"]`);
            
            if (movieCardContainer) {
                // Add a removal animation
                const movieCard = movieCardContainer.querySelector('.movie-card');
                const isSwipingRight = movieCard.style.transform.includes('translateX(1');
                
                // Set appropriate background color based on swipe direction
                if (isSwipingRight) {
                    movieCardContainer.querySelector('.swipe-hint-left').style.opacity = 1;
                    
                    // Increase likes count if swiped right (like)
                    const movieIndex = movies.findIndex(m => m.imdbID === movieId);
                    if (movieIndex !== -1) {
                        movies[movieIndex].likesCount++;
                    }
                } else {
                    movieCardContainer.querySelector('.swipe-hint-right').style.opacity = 1;
                    
                    // Increase dislikes count if swiped left (dislike)
                    const movieIndex = movies.findIndex(m => m.imdbID === movieId);
                    if (movieIndex !== -1) {
                        movies[movieIndex].dislikesCount++;
                    }
                }
                
                movieCard.style.transform = isSwipingRight ? 'translateX(100vw)' : 'translateX(-100vw)';
                movieCard.style.transition = 'transform 0.3s ease-out';
                
                // Remove from DOM after animation
                setTimeout(() => {
                    movieCardContainer.remove();
                    
                    // Update movies array
                    movies = movies.filter(movie => movie.imdbID !== movieId);
                    
                    // Re-apply current filter to update view
                    filterMoviesByGenre(activeGenre);
                }, 300);
            }
        }
        
        // Current active genre filter
        let activeGenre = 'all';
        
        // Reset movie list
        function resetMovieList() {
            movies = [...originalMovies];
            filterMoviesByGenre(activeGenre);
            updateMovieCount();
        }
        
        // Filter movies by genre
        function filterMoviesByGenre(genre) {
            activeGenre = genre;
            
            // Update active class on genre tags
            const genreTags = document.querySelectorAll('.genre-tag');
            genreTags.forEach(tag => {
                if (tag.dataset.genre === genre) {
                    tag.classList.add('active');
                } else {
                    tag.classList.remove('active');
                }
            });
            
            // Filter movies
            const filteredMovies = genre === 'all' 
                ? movies 
                : movies.filter(movie => {
                    return movie.genre.toLowerCase().includes(genre.toLowerCase());
                });
            
            // Render filtered movies
            renderMovies(filteredMovies);
        }
        
        // Populate movies list
        function renderMovies(moviesToRender = movies) {
            const movieListElement = document.getElementById('movieList');
            movieListElement.innerHTML = '';
            
            if (moviesToRender.length === 0) {
                // Show empty state with different message for filters
                const emptyStateElement = document.getElementById('emptyState');
                if (activeGenre !== 'all') {
                    emptyStateElement.querySelector('p').textContent = `No movies found in the "${activeGenre}" genre`;
                } else {
                    emptyStateElement.querySelector('p').textContent = 'No more movies in your list';
                }
                emptyStateElement.style.display = 'block';
            } else {
                document.getElementById('emptyState').style.display = 'none';
                
                moviesToRender.forEach(movie => {
                    const movieCard = createMovieCard(movie);
                    movieListElement.appendChild(movieCard);
                });
            }
            
            // Update the movie count to show filtered count / total
            const movieCountElement = document.getElementById('movieCount');
            movieCountElement.textContent = activeGenre === 'all' 
                ? `(${moviesToRender.length})` 
                : `(${moviesToRender.length}/${movies.length})`;
        }
        
        // Share movie function
        function shareMovie(movieId) {
            try {
                const movie = movies.find(m => m.imdbID === movieId);
                if (!movie) return;
                
                if (window.Telegram && window.Telegram.WebApp) {
                    const webApp = window.Telegram.WebApp;
                    
                    // Try to use Telegram's native sharing
                    if (webApp.showShareScreen) {
                        webApp.showShareScreen({
                            text: `Check out this movie: ${movie.title} (${movie.year}) - ${movie.description}`,
                            buttonText: "Share Movie"
                        });
                    } else {
                        // Fallback to a regular share dialog if available
                        try {
                            if (navigator.share) {
                                navigator.share({
                                    title: movie.title,
                                    text: `Check out this movie: ${movie.title} (${movie.year}) - ${movie.description}`
                                });
                            } else {
                                // If no sharing capability, just show a message
                                alert(`Sharing: ${movie.title} (${movie.year})`);
                            }
                        } catch (shareError) {
                            alert(`Sharing: ${movie.title} (${movie.year})`);
                        }
                    }
                } else {
                    // Not in Telegram, try to use Web Share API
                    try {
                        if (navigator.share) {
                            navigator.share({
                                title: movie.title,
                                text: `Check out this movie: ${movie.title} (${movie.year}) - ${movie.description}`
                            });
                        } else {
                            // No sharing capability
                            alert(`Sharing: ${movie.title} (${movie.year})\n\nCopy this text to share:\n${movie.title} (${movie.year}) - ${movie.description}`);
                        }
                    } catch (webShareError) {
                        alert(`Sharing: ${movie.title} (${movie.year})`);
                    }
                }
            } catch (error) {
                showError(error, 'Error sharing movie');
            }
        }
        
        
        // Debug panel functionality
        /*document.getElementById('debugPanel').addEventListener('click', function() {
            try {
                const webAppInfo = window.Telegram && window.Telegram.WebApp ? 
                    JSON.stringify(window.Telegram.WebApp.initDataUnsafe, null, 2) : 
                    'WebApp not available';
                
                showError('Debug Info (Not an error)', webAppInfo);
            } catch (e) {
                showError(e);
            }
        });*/
        
        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // Add reset button functionality
                document.getElementById('resetBtn').addEventListener('click', resetMovieList);
                
                // Setup genre filter click handlers
                const genreTags = document.querySelectorAll('.genre-tag');
                genreTags.forEach(tag => {
                    tag.addEventListener('click', () => {
                        filterMoviesByGenre(tag.dataset.genre);
                    });
                });
                
                // Initialize movies list
                initializeMovies();
                
                // Check if Telegram WebApp is available
                if (window.Telegram && window.Telegram.WebApp) {
                    // Initialize Telegram WebApp
                    const webApp = window.Telegram.WebApp;
                    
                    // Log init data for debugging
                    console.log('WebApp initData available:', !!webApp.initData);
                    
                    // Expand to maximum allowed height
                    webApp.expand();
                    
                    try {
                        // Configure theme colors if needed
                        if (webApp.themeParams) {
                            console.log('Theme params available:', webApp.themeParams);
                        }
                        
                        // Trigger closing animation when ready
                        webApp.ready();
                    } catch (dataError) {
                        console.error('Error accessing web app data:', dataError);
                    }
                } else {
                    // Not running in Telegram - still show all functionality
                    const notificationElement = document.getElementById('notTelegram');
                    notificationElement.style.display = 'block';
                    notificationElement.innerHTML = 'You\'re viewing this app outside of Telegram. Some features might be limited.';
                    
                    console.warn('Telegram WebApp not available - running in standalone mode');
                }
            } catch (error) {
                showError(error, 'Error initializing app');
            }
        });

        // Add this function to parse IMDb ID from URL
        function parseImdbIdFromUrl(url) {
            try {
                const match = url.match(/\/title\/(tt\d+)/i);
                return match ? match[1] : null;
            } catch (error) {
                return null;
            }
        }

        // Add this function to fetch movie data from OMDB API
        async function fetchMovieData(imdbId) {
            const API_KEY = '1c1f6484'; // You'll need to replace this with actual API key
            const response = await fetch(`https://www.omdbapi.com/?i=${imdbId}&apikey=${API_KEY}`);
            if (!response.ok) {
                throw new Error('Failed to fetch movie data');
            }
            return response.json();
        }

        // Add this function to handle adding a single movie
        async function addMovie(imdbUrl, addToStart = false) {
            const imdbId = parseImdbIdFromUrl(imdbUrl);
            if (!imdbId) {
                throw new Error('Invalid IMDb URL. Please enter a valid URL (e.g., https://www.imdb.com/title/tt0062455)');
            }
            
            const movieData = await fetchMovieData(imdbId);
            
            if (movieData.Response === 'False') {
                throw new Error(movieData.Error || 'Failed to fetch movie data');
            }
            
            // Check if movie already exists
            if (movies.some(m => m.imdbID === movieData.imdbID)) {
                throw new Error('This movie is already in your list');
            }
            
            // Create new movie object
            const newMovie = {
                imdbID: movieData.imdbID,
                title: movieData.Title,
                year: parseInt(movieData.Year),
                genre: movieData.Genre,
                description: movieData.Plot,
                likesCount: 1,
                dislikesCount: 0,
                poster: movieData.Poster,
                imdbRating: movieData.imdbRating
            };
            
            // Add to movies array at start or end
            if (addToStart) {
                movies.unshift(newMovie);
            } else {
                movies.push(newMovie);
            }
            
            return newMovie;
        }

        // Update initialization function
        async function initializeMovies() {
            try {
                // Clear existing movies
                movies = [];
                
                // Fetch data for each sample movie URL
                for (const url of sampleMovieUrls) {
                    try {
                        await addMovie(url);
                    } catch (error) {
                        console.warn(`Error adding movie from ${url}:`, error);
                    }
                }

                for (const movie of movies) {
                    movie.likesCount = Math.floor(Math.random() * 100) + 1;
                    movie.dislikesCount = Math.floor(Math.random() * 100) + 1;
                }
                
                // Store original movies for reset functionality
                originalMovies.splice(0, originalMovies.length, ...movies);
                
                // Render the movies list
                filterMoviesByGenre(activeGenre);
                
            } catch (error) {
                showError('Failed to initialize movies', error);
            }
        }

        // Update Add Movie button click handler
        document.getElementById('addMovieBtn').addEventListener('click', async function() {
            try {
                const imdbUrl = document.getElementById('imdbUrl').value.trim();
                
                // Add movie to start of list
                await addMovie(imdbUrl, true);
                
                // Clear input
                document.getElementById('imdbUrl').value = '';
                
                // Re-render movies list
                filterMoviesByGenre(activeGenre);
                
                // Show success message
                showError('Movie added successfully!');
                setTimeout(() => {
                    const errorContainer = document.getElementById('errorContainer');
                    errorContainer.style.display = 'none';
                }, 2000);
                
            } catch (error) {
                showError(error);
            }
        });
    </script>
</body>
</html>
